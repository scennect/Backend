<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scennect</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.0/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- <link rel="stylesheet" type="text/css" href="/css/style.css"> -->
    <link rel="stylesheet" type="text/css" href="./css/style.css">
    <!-- <style>
        .cursor {
            position: absolute;
            width: 10px; /* 커서 크기 조정 */
            height: 10px; /* 커서 크기 조정 */
            background: red; /* 커서 색상 */
            border-radius: 50%; /* 원형으로 만들기 */
            pointer-events: none; /* 클릭 이벤트 차단 */
            z-index: 1000; /* 다른 요소 위에 표시 */
        }

        .node-box {
            border: 2px solid #ccc; /* 박스 테두리 */
            border-radius: 5px; /* 박스 모서리 둥글게 */
            padding: 10px; /* 안쪽 여백 */
            margin: 10px; /* 박스 간격 */
            display: inline-block; /* 인라인 블록으로 나란히 배치 */
            width: 150px; /* 박스 너비 */
            text-align: center; /* 텍스트 가운데 정렬 */
            position: absolute; /* 위치 조정 가능하도록 설정 */
            cursor: move; /* 마우스 커서를 드래그 가능으로 변경 */
        }

        .node-image {
            max-width: 100%; /* 이미지가 박스를 넘어가지 않도록 조정 */
            height: auto; /* 비율 유지 */
        }

        .moving {
            border-color: yellow; /* 움직이는 동안 테두리 색상 변경 */
            border-width: 3px; /* 테두리 두께 변경 */
        }

        /* 노드 생성 폼 스타일 */
        .node-form-box {
            border: 2px solid #007bff; /* 박스 테두리 색상 */
            border-radius: 5px; /* 모서리 둥글게 */
            padding: 15px; /* 안쪽 여백 */
            margin: 10px; /* 박스 간격 */
            display: inline-block; /* 인라인 블록으로 나란히 배치 */
            width: 200px; /* 박스 너비 */
            text-align: center; /* 텍스트 가운데 정렬 */
            position: absolute; /* 위치 조정 가능하도록 설정 */
            cursor: move; /* 마우스 커서를 드래그 가능으로 변경 */
        }
    </style> -->
</head>
<body data-bs-theme="dark">
    <div id="background"></div>
    <div id="ui">
        <!-- Project ID 입력 폼 -->
        <div id="form-ID">
            <h1>Scennect</h1>
            <form id="projectForm">
            
              <label for="projectId">Project ID:</label>
              <input id="projectId" class="form-control" placeholder="Project ID" required>
              
              <button class="btn btn-secondary" type="submit">Load Project</button>
          </form>
        </div>
    </div>


<div id="projectDetails"></div>

<!-- 노드 생성 폼 -->
<div id="nodeForm" class="node-form-box"> <!-- 박스 형태로 변경 -->
    <h3>Generate New Img</h3>
    <form id="form">
        <!-- <label for="prompt">프롬프트:</label>
        <input type="text" id="prompt" required>
        <label for="parentNodeId">부모 노드 ID:</label>
        <textarea type="text" id="parentNodeId" required></textarea>
        <button type="submit">Create Node</button> -->

        <label for="parentNodeId">Parent Node ID:</label>
        <input id="parentNodeId" class="form-control" placeholder="Parent Node ID">
        <label for="prompt">Prompt:</label>
        <textarea type="text" id="prompt" class="form-control" placeholder="Prompt" required></textarea>
        <button class="btn generateBtn btn-primary" type="submit">Create Node</button>
    </form>
</div>

<div id="nodesContainer" style="display:inherit;">
    <h2>Nodes:</h2>
    <div id="nodesList">

        <div id="node-0" class="node-box test" style="top: 400px; left: 600px;">
            <div class="btn-wrap-close" onclick="deleteNode('node-0')"><button type="button" class="btn-close" aria-label="Close"></button></div>
            <div class="info">
                <p>Prompt:</p>
                <div class="prompt">Apple on the Table, oil painting</div>
            </div>
            <img src="https://hongik-s3.s3.amazonaws.com/42_10_7.5.png" alt="test node1" style="height: auto;">
        </div>


    </div> <!-- 리스트를 div로 감싸서 박스 형태로 변경 -->
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

<script>
    const background = document.getElementById('background');
    let isDragging = false;
    let startX, startY, scrollLeft, scrollTop;

    background.addEventListener('mousedown', (e) => {
      isDragging = true;
      background.style.cursor = 'grabbing';
      startX = e.pageX - background.offsetLeft;
      startY = e.pageY - background.offsetTop;
      scrollLeft = window.scrollX;
      scrollTop = window.scrollY;
    });

    background.addEventListener('mouseleave', () => {
      isDragging = false;
      background.style.cursor = 'grab';
    });

    background.addEventListener('mouseup', () => {
      isDragging = false;
      background.style.cursor = 'grab';
    });

    background.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const x = e.pageX - startX;
      const y = e.pageY - startY;
      window.scrollTo(scrollLeft - x, scrollTop - y);
    });
</script>







<script>
    const projectForm = document.getElementById('projectForm');
    const nodeForm = document.getElementById('nodeForm');
    const projectDetails = document.getElementById('projectDetails');
    const nodesContainer = document.getElementById('nodesContainer');
    const nodesList = document.getElementById('nodesList');
    let stompClient = null;
    const userCursors = {}; // 사용자의 커서와 이름을 보여줄 요소를 저장할 객체

    // Project ID 입력 폼 처리
    projectForm.addEventListener('submit', function(event) {
        event.preventDefault();
        const projectId = document.getElementById('projectId').value;

        // /project/{projectId}로 GET 요청
        fetch(`/project/${projectId}`, {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "access": `${localStorage.getItem('access')}` // Access Token 추가
            }
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok ' + response.statusText);
                }
                return response.json();
            })
            .then(data => {
                console.log("Project loaded:", data);
                projectDetails.innerHTML = `<p>Project ID: ${data.data.id}, Project Name: ${data.data.projectName}</p>`;

                // 사용자 이름 저장
                currentUserName = data.data.projectUserName; // 사용자 이름 저장

                // 노드 목록 초기화
                nodesList.innerHTML = ""; // Clear previous nodes

                // 노드 목록을 화면에 표시
                data.data.nodes.forEach(node => {
                    addNodeToList(node);
                });

                // 프로젝트가 성공적으로 로드되면 노드 관련 기능 표시
                nodeForm.style.display = 'block';
                nodesContainer.style.display = 'block';

                // WebSocket 연결 시작
                connectWebSocket(projectId);
            })
            .catch(error => {
                console.error("Error loading project:", error);
            });
    });

    // WebSocket 연결 함수
    function connectWebSocket(projectId) {
        const socket = new SockJS('/ws'); // 서버의 WebSocket 엔드포인트
        stompClient = Stomp.over(socket);

        stompClient.connect({
            "access": `${localStorage.getItem('access')}` // Access Token 추가
        }, function (frame) {
            console.log('Connected: ' + frame);

            // WebSocket을 통해 노드 정보 실시간으로 받는 구독 설정
            stompClient.subscribe(`/topic/project/${projectId}`, function (message) {
                const newNode = JSON.parse(message.body);
                addNodeToList(newNode);
            });

            // WebSocket을 통해 들어온 노드 좌표 데이터를 처리
            stompClient.subscribe(`/topic/node/${projectId}`, function (message) {
                const nodeData = JSON.parse(message.body);

                // 전송된 nodeId로 해당 노드 요소를 찾음
                const nodeElement = document.getElementById(`node-${nodeData.nodeId}`);

                if (nodeElement) {
                    // 노드의 위치를 새로운 좌표로 업데이트
                    nodeElement.style.left = `${nodeData.x}px`;
                    nodeElement.style.top = `${nodeData.y}px`;
                } else {
                    console.error(`Node with ID ${nodeData.nodeId} not found.`);
                }
            });

            // WebSocket을 통해 마우스 좌표 수신
            stompClient.subscribe(`/topic/mouse/${projectId}`, function (message) {
                const mouseData = JSON.parse(message.body);
                const { name, x, y } = mouseData;

                // 커서 요소가 이미 존재하는지 확인
                if (!userCursors[name]) {
                    // 커서 요소 생성
                    const cursorElement = document.createElement('div');
                    cursorElement.className = 'cursor';
                    cursorElement.style.position = 'absolute';
                    cursorElement.innerHTML = `<span>${name}</span>`;
                    document.body.appendChild(cursorElement);

                    // 사용자 커서 저장
                    userCursors[name] = cursorElement;
                }

                // 커서 위치 업데이트
                const cursorElement = userCursors[name];
                cursorElement.style.left = `${x}px`;
                cursorElement.style.top = `${y}px`;
            });

        });
    }

    // 마우스 움직임 감지 및 WebSocket으로 전송
    document.addEventListener('mousemove', function(event) {
        if (stompClient && stompClient.connected) {
            const mouseData = {
                name: currentUserName, // 사용자 이름 추가
                x: event.clientX,
                y: event.clientY
            };
            stompClient.send(`/app/mouse/${document.getElementById('projectId').value}`, {}, JSON.stringify(mouseData));
        }
    });

    // 드래그 가능한 기능을 추가하는 함수
    function makeDraggable(element) {
        let offsetX, offsetY;

        element.addEventListener('mousedown', function(event) {
            offsetX = event.clientX - element.getBoundingClientRect().left;
            offsetY = event.clientY - element.getBoundingClientRect().top;

            document.addEventListener('mousemove', dragElement);
            document.addEventListener('mouseup', stopDrag);
        });

        function dragElement(event) {
            element.style.left = `${event.clientX - offsetX}px`;
            element.style.top = `${event.clientY - offsetY}px`;
        }

        function stopDrag() {
            document.removeEventListener('mousemove', dragElement);
            document.removeEventListener('mouseup', stopDrag);
        }
    }

    // 페이지 로드 시 노드 생성 폼 드래그 가능하게 설정
    window.onload = function() {
        nodeForm.style.left = '10vw'; // 초기 x 좌표 설정
        nodeForm.style.top = '30vh'; // 초기 y 좌표 설정
        makeDraggable(nodeForm); // 드래그 기능 추가

        const nodeFormElement = document.getElementById('form');
        nodeFormElement.addEventListener('submit', function(event) {
            event.preventDefault();

            const prompt = document.getElementById('prompt').value;
            const parentNodeId = document.getElementById('parentNodeId').value;
            const x = parseInt(nodeForm.style.left, 10); // 폼의 현재 x 좌표
            const y = parseInt(nodeForm.style.top, 10); // 폼의 현재 y 좌표

            fetch('/create-node', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    prompt: prompt,
                    parentNodeId: parentNodeId,
                    x: x,
                    y: y
                }),
            })
                .then(response => response.json())
                .then(data => {
                    console.log('Node created:', data);
                })
                .catch(error => {
                    console.error('Error creating node:', error);
                });
        });
    };

    function makeNodeDraggable(nodeElement, nodeId) {
        let offsetX, offsetY;

        // 드래그 시작 시 처리
        nodeElement.addEventListener('mousedown', function(event) {
            offsetX = event.clientX - nodeElement.getBoundingClientRect().left; // 마우스 X 위치
            offsetY = event.clientY - nodeElement.getBoundingClientRect().top; // 마우스 Y 위치

            // 드래그 중에 노란색 테두리 적용
            nodeElement.style.border = '2px solid yellow'; // 노란색 테두리로 변경

            // 문서에 마우스 이동 이벤트 리스너 추가
            document.addEventListener('mousemove', dragNode);

            // 마우스 버튼이 떼어지면 드래그 종료
            document.addEventListener('mouseup', stopDrag);
        });

        // 노드 드래그 함수
        function dragNode(event) {
            nodeElement.style.left = `${event.clientX - offsetX}px`; // 새로운 X 위치 설정
            nodeElement.style.top = `${event.clientY - offsetY}px`; // 새로운 Y 위치 설정

            // 노드 이동 정보를 다른 사용자에게 전송하는 로직 추가 가능
            const nodeData = {
                nodeId: nodeId,
                x: parseInt(nodeElement.style.left, 10),
                y: parseInt(nodeElement.style.top, 10)
            };

            // WebSocket을 통해 다른 사용자에게 노드의 새로운 위치 전송
            stompClient.send(`/app/node/${document.getElementById('projectId').value}`, {}, JSON.stringify(nodeData));
        }

        // 드래그 종료 함수
        function stopDrag() {
            // 드래그 종료 시 테두리 원래 색으로 되돌리기
            nodeElement.style.border = '2px solid black'; // 원래의 테두리 색으로 복원

            // 현재 노드 좌표를 서버로 전송하여 데이터베이스에 저장
            const nodeData = {
                x: parseInt(nodeElement.style.left, 10),
                y: parseInt(nodeElement.style.top, 10)
            };

            // 서버로 PATCH 요청을 보내 좌표 업데이트 (데이터베이스에 반영)
            fetch(`/node/${nodeId}`, {
                method: 'PATCH',
                headers: {
                    "Content-Type": "application/json",
                    "access": `${localStorage.getItem('access')}` // Access Token 추가
                },
                body: JSON.stringify(nodeData)
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to update node coordinates in database');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log("Node coordinates updated:", data);
                })
                .catch(error => {
                    console.error("Error updating node coordinates:", error);
                });

            // 이벤트 리스너 제거
            document.removeEventListener('mousemove', dragNode);
            document.removeEventListener('mouseup', stopDrag);
        }
    }

    // 노드 위치 업데이트
    function moveNode(moveData) {
        const nodeElement = document.getElementById(`node-${moveData.id}`);
        if (nodeElement) {
            nodeElement.style.left = `${moveData.x}px`;
            nodeElement.style.top = `${moveData.y}px`;
            nodeElement.classList.add('moving'); // 움직일 때 테두리 색상 변경

            // 잠시 후 테두리 원래 색으로 복원
            setTimeout(() => {
                nodeElement.classList.remove('moving');
            }, 1000); // 1초 후에 원래 색으로 복원
        }
    }

    // 노드 생성 폼 처리
    nodeForm.addEventListener('submit', function(event) {
        event.preventDefault();

        const prompt = document.getElementById('prompt').value;
        const parentNodeId = document.getElementById('parentNodeId').value;
        const projectId = document.getElementById('projectId').value;

        // 현재 마우스 좌표를 가져옴
        const x = event.clientX; // 마우스의 X 좌표
        const y = event.clientY; // 마우스의 Y 좌표

        const nodeData = {
            prompt: prompt,
            parentNodeId: parentNodeId,
            projectId: projectId,
            x: x, // X 좌표 추가
            y: y  // Y 좌표 추가
        };

        // 서버로 노드 생성 요청
        fetch('/node', {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "access": `${localStorage.getItem('access')}` // Access Token 추가
            },
            body: JSON.stringify(nodeData)
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok ' + response.statusText);
                }
                return response.json();
            })
            .then(data => {
                console.log("Node created:", data);
                addNodeToList(data); // 새로 생성된 노드를 화면에 추가
            })
            .catch(error => {
                console.error("Error creating node:", error);
            });
    });

    // 노드를 화면에 추가하는 함수
    function addNodeToList(node) {
        const nodeElement = document.createElement('div');
        nodeElement.id = `node-${node.id}`; // 각 노드에 고유 ID 추가
        nodeElement.className = 'node-box'; // CSS 스타일 적용을 위한 클래스

        // 노드의 스타일 설정 // nodeStyle
        //nodeElement.style.position = 'absolute'; // 절대 위치 설정
        nodeElement.style.left = `${node.x}px`; // 초기 x 좌표 설정
        nodeElement.style.top = `${node.y}px`; // 초기 y 좌표 설정
        //nodeElement.style.border = '2px solid black'; // 테두리 설정
        //nodeElement.style.padding = '10px'; // 패딩 추가
        //nodeElement.style.margin = '5px'; // 마진 추가
        //nodeElement.style.backgroundColor = 'white'; // 배경색 설정
        //nodeElement.style.zIndex = '10'; // z-index 설정으로 다른 요소 위에 보이게

        // // 노드 내용을 추가
        // nodeElement.innerHTML = `<h3>${node.prompt}</h3>`; // 노드의 프롬프트 추가
        // nodeElement.innerHTML = `<div class="btn-wrap-close"><button type="button" class="btn-close" aria-label="Close"></button></div>`; // 삭제버튼 추가
        //nodeElement.innerHTML = `<div class="info"><p>Prompt:</p><div class="prompt">${node.prompt}</div></div>`; // 노드의 프롬프트 추가

        

        nodeElement.innerHTML = `<div class="btn-wrap-close" onclick="deleteNode('node-${node.id}', ${node.id})"><button type="button" class="btn-close" aria-label="Close"></button></div><div class="info"><p>Prompt:</p><div class="prompt">${node.prompt}</div></div>`;

        // 이미지 URL이 있으면 이미지 태그 추가
        if (node.imageURL) {
            const imageElement = document.createElement('img');
            const cleanImageURL = node.imageURL.replace(/['"]+/g, ''); // URL에서 따옴표 제거
            imageElement.src = cleanImageURL; // 수정된 URL 사용
            imageElement.alt = node.prompt;
            imageElement.style.width = '100%'; // 이미지 너비 설정
            imageElement.style.height = 'auto'; // 높이는 자동으로 설정
            nodeElement.appendChild(imageElement); // 노드 박스에 이미지 추가
        }


        // 노드 드래그 가능하도록 설정
        makeNodeDraggable(nodeElement, node.id);

        // 노드를 리스트에 추가
        nodesList.appendChild(nodeElement);
        //console.log(`Node ${node.id} added to the DOM at (${node.x}, ${node.y})`); // Log for debugging
    }

    // 노드 지우기 함수
    function deleteNode(nodeID, nodeIdNumOnly) {
        console.log("deleteNode");
        // DELETE API 호출
        fetch(`/node/${nodeIdNumOnly}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                "access": `${localStorage.getItem('access')}` // Access Token 추가
            }
        })
        .then(response => {
            if (response.ok) {
                console.log("Node deleted successfully.");
                // Node 삭제
                document.getElementById(nodeID).remove();
            } else {
                return response.json().then(err => {
                    console.error("Failed to delete node:", err.message);
                });
            }
        })
        .catch(error => {
            console.error("Error deleting node:", error);
        });
    }
</script>
</body>
</html>